<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Perspective Transform with HTML5 Canvas</title>
<style>
  canvas {
    border: 1px solid black;
  }
  #overlayCanvas {
    opacity: 0.5; /* 设置覆盖层的透明度 */
    pointer-events: none; /* 防止覆盖层拦截鼠标事件 */
    left: 10px;
    top:10px;
    border: 1px solid black;
    position: absolute;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<canvas id="overlayCanvas"></canvas>
<canvas id="copy_canvas"></canvas>
<!-- <script src="../static/perspective.js"></script> -->
<script>
// 定义一些全局变量
let canvas, ctx, transformedCanvas, transformedCtx, srcImg, dstImg, srcPoints, dstPoints, selectedPoint = -1;
let ipm=[[1,0,0],[0,1,0],[0,0,1]];
function dot(matrixA, matrixB) {
    if (matrixA[0].length !== matrixB.length) {
        throw "矩阵尺寸不兼容";
    }

    var result = [];
    for (var i = 0; i < matrixA.length; i++) {
        result[i] = [];
        for (var j = 0; j < matrixB[0].length; j++) {
            var sum = 0;
            for (var k = 0; k < matrixA[0].length; k++) {
                sum += matrixA[i][k] * matrixB[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}


// 初始化Canvas和图像
function initCanvas() {
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  copy_canvas=document.getElementById('copy_canvas');
  copy_ctx=copy_canvas.getContext('2d');
  srcImg = new Image();
  srcImg.onload = () => {
    canvas.width = srcImg.width;
    canvas.height = srcImg.height;
    ctx.drawImage(srcImg,0,0,canvas.width,canvas.height);
    copy_canvas.width=srcImg.width;
    copy_canvas.height=srcImg.height;
    copy_ctx.drawImage(srcImg,0,0);
    resetPoints();
    // drawScene();
  };
  srcImg.src = 'static/court.png'; // 替换为你的图像路径

  let overImg=new Image();
  overImg.onload=()=>{
    over_canvas=document.getElementById('overlayCanvas');
    over_ctx=over_canvas.getContext('2d');
    over_canvas.width=overImg.width*0.65;
    over_canvas.height=overImg.height*0.65;
    over_ctx.drawImage(overImg,0,0,over_canvas.width,over_canvas.height);
  }
  overImg.src='static/R4.png';
}

// 重置映射点到默认位置
function resetPoints() {
  srcPoints = [
    // { x: 0, y: 0 },
    // { x: canvas.width, y: 0 },
    // { x: canvas.width, y: canvas.height },
    // { x: 0, y: canvas.height }
  ];
  dstPoints = [
    // { x: 0, y: 0 },
    // { x: canvas.width , y: 0 },
    // { x: canvas.width , y: canvas.height  },
    // { x: 0, y: canvas.height  }
  ];
}

// 绘制场景
function drawScene() {
//   ctx.clearRect(0, 0, canvas.width, canvas.height);
  applyPerspectiveTransform();
  drawPoints();
}

// 绘制映射点
function drawPoints() {
  for (let i = 0; i < dstPoints.length; i++) {
    drawPoint(dstPoints[i], selectedPoint === i ? 'red' : 'yellow');
  }
}

// 绘制单个点
function drawPoint(point, color, context=ctx,radus=20,alpha=0.3) {
    context.globalAlpha = alpha;
    context.beginPath();
    context.arc(point.x, point.y, radus, 0, 2 * Math.PI);
    context.fillStyle = color;
    context.fill();
    context.closePath();
    context.globalAlpha = 1;
}

// 处理鼠标点击事件
function handleMouseDown(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  if(srcPoints.length<4){
    let point={x:x,y:y};
    srcPoints.push(point);
    dstPoints.push(point);
    drawPoint(point,'yellow',context=ctx,radus=20,alpha=0.3);
    return;
  }
  for (let i = 0; i < 4; i++) {
    if (Math.sqrt(Math.pow(x - dstPoints[i].x, 2) + Math.pow(y - dstPoints[i].y, 2)) <= 20) {
      selectedPoint = i;
      return;
    }
    else{
        drawPoint({x:x,y:y},'blue',ctx,5);
        let input_point=[[x],[y],[1]];
        let output_point;
        if(ipm){
            output_point=dot(ipm,input_point);
            output_point[0]/=output_point[2];
            output_point[1]/=output_point[2];
            drawPoint({x:output_point[0],y:output_point[1]},'blue',copy_ctx,5);
            console.log(output_point);
        }
    }
  }
  selectedPoint = -1;
}

// 处理鼠标移动事件
function handleMouseMove(event) {
  if (selectedPoint >= 0) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    dstPoints[selectedPoint] = { x, y };
    // console.log(x,y);
    drawScene();
  }
}

// 处理鼠标释放事件
function handleMouseUp(event) {
  if (selectedPoint >= 0) {
    applyPerspectiveTransform();
    selectedPoint = -1;
  }
}

// // 应用透视变换
function applyPerspectiveTransform() {
    const data = {
      src_points: srcPoints,
      dst_points: dstPoints
    };
    fetch('/calculate_perspective_matrix', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        ipm=data.perspective_matrix;
      // 假设 response 是从后端收到的 JSON 响应对象
        var outputImageBase64 = data.output_image_base64;

        // 创建一个新的图像元素
        var img = new Image();

        // 设置图像的 base64 编码字符串作为源
        img.src = 'data:image/jpeg;base64,' + outputImageBase64;

        // 将图像添加到页面中
        // document.body.appendChild(img);
        img.onload = function() {
            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            drawPoints();
        };
      // 这里可以根据需要处理从服务器端接收到的透视变换矩阵
    })
    .catch(error => {
      console.error('Error:', error);
    });    
    drawPoints();
}


// 设置事件监听器
function setupEventListeners() {
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseup', handleMouseUp);
}

// 当DOM加载完成后初始化Canvas并设置事件监听器
document.addEventListener('DOMContentLoaded', function() {
  initCanvas();
  setupEventListeners();
});
</script>
</body>
</html>
