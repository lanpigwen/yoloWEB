<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shooting Practice</title>
    <!-- 引入 Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>

        /* 自定义CSS可以在此处添加 */
        /* 可以进行与页面布局相匹配的调整 */
        #topCanvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* 固定画布高度为16:9的比例 */
            background-color: black; /* 修改背景色为黑色 */
            overflow: hidden; /* 隐藏视频溢出部分 */
        }
        #resultCanvas {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 5;
            object-fit: contain;
            
        }
        #BalltempCanvas {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 5;
            object-fit: contain;
            
        }
        #bottomControls {
            padding: 10px; /* 控制栏内边距 */
            border-top: 1px solid #dee2e6; /* 控制栏上边框 */
            position: fixed; /* 绝对定位 */
            bottom: 20px; /* 底部对齐，并留出一定的间距 */
            left: 50%;
            transform: translateX(-50%);
            width: 90%; /* 宽度90%，留出一定的边距 */
            background-color: rgba(248, 249, 250, 0.8); /* 使用 rgba() 来定义背景色和透明度 */
            border-radius: 10px; /* 圆角处理，应用于所有四个角 */
            z-index: 99;
        }

        #videoElement {
            /* display: none; */
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 6;
            object-fit: contain;
            /* opacity: 0.5; */
            /* transform: scaleX(-1); */
        }

        #resultImg{
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 5;
            object-fit: contain;
        }

    </style>
    
<style>
    body {
        background-color: black; /* 设置页面背景颜色为黑色 */
        overflow: hidden;
        margin:0;
    }

    .score-raise {
        color: white; /* 设置文本颜色为白色 */
        font-size: calc(var(--size)*0.75); /* 设置字体大小 */
        font-weight: bold; /* 设置字体粗细 */
    }

    #scoreDisplay {
        --canvasLeft:10px;
        --canvasTop:10px;
        --canvasWidth:200px;
        --canvasHeight:200px;
        --scoreDisplayWidth:calc(var(--canvasWidth)*0.155);
        --scoreDisplayHeight:calc(var(--canvasHeight)*0.17);
        --offset: calc(var(--canvasWidth)*0.15*0.15);

        position: fixed;
        bottom: calc(var(--canvasTop));
        border-radius: 10%; 
        color: white; 
        display: flex; 
        align-items: center;
        justify-content: center; 
        z-index: 99;
    }

    #scoreDisplay .spanLeftRight{
        margin-right: calc(var(--scoreDisplayWidth)*0.2);
    }
    #scoreDisplay .scoreNum {
        font-size: calc(var(--scoreDisplayWidth)*0.5);
        line-height: 1;
        display: grid;
        place-items: center;
        font-weight: bold;
        
    }

    #scoreDisplay .xie {
        font-size: calc(var(--scoreDisplayWidth)*0.7);
        line-height: 1;
        display: flex;
        align-items: center;
        font-weight: 25;
        transform: translateY(-5%);
        transform-origin: bottom center; /* 设置旋转中心点为底部中心 */
    }


    #scoreDisplay .underScoreNumText {
        display: grid;
        place-items: center;
        font-weight: bold;
        font-size:calc(var(--scoreDisplayWidth)*0.15);;
        line-height: 1;
    }


    
    #TimeDisplay {
        --canvasLeft:10px;
        --canvasTop:10px;
        --canvasWidth:200px;
        --canvasHeight:200px;
        --scoreDisplayWidth:calc(var(--canvasWidth)*0.175);
        --scoreDisplayHeight:calc(var(--canvasHeight)*0.17);
        --offset: calc(var(--canvasWidth)*0.15*0.15);

        position: fixed;
        left: var(--canvasLeft);
        top: var(--canvasTop);
        margin-left: var(--offset);
        margin-top: var(--offset);
        font-size: calc(var(--scoreDisplayWidth)*0.35); /* 字体大小 */
        width:var(--scoreDisplayWidth);
        height:var(--scoreDisplayHeight);
        border-radius: 10%; /* 圆角 */
        background-color: rgba(0, 0, 0, 0.5); /* 背景色为透明黑色 */
        color: white; /* 文本颜色为白色 */
        display: flex; /* 使用 Flexbox 布局 */
        align-items: center; /* 垂直居中 */
        justify-content: center; /* 水平居中 */
        transition: transform 0.2s ease-in-out; /* 变换效果 */
        z-index: 99;
    }

    #Time {
        display: grid;
        place-items: center;
        font-weight: bold;
    }


    #CourtDisplay {
        --canvasLeft:10px;
        --canvasTop:10px;
        --canvasWidth:200px;
        --canvasHeight:200px;
        --scoreDisplayWidth:calc(var(--canvasWidth)*0.195);
        --scoreDisplayHeight:calc(var(--canvasHeight)*0.17);
        --offset: calc(var(--canvasWidth)*0.15*0.10);

        position: fixed;
        right: var(--canvasLeft);
        top: var(--canvasTop);
        margin-right: var(--offset);
        z-index: 99;
        pointer-events: none;
    }

  
</style>
<style>
    #court_canvas{
        position: absolute;
        z-index: 10;
        opacity: 0.5;
    }
    #copy_canvas {
        /* opacity: 1; */
        pointer-events: none;
        /* border-bottom-left-radius: 10%;
        border-bottom-right-radius: 10%; */
        /* overflow: hidden; */
        /* border-radius: 10%; */
        /* 防止覆盖层拦截鼠标事件 */
        /* right: 0px;
        top: 0px;
        border: 1px solid black;
        position: absolute; */
    }
</style>
<!-- <style>

.dropdown-menu-x {
  flex-direction: row;
  overflow-x: auto;
  white-space: nowrap; 
  padding: 0.5rem 0; 
}


.dropdown-item {
  display: flex;
  align-items: center; 
  padding: 0.5rem; 
}


@media (max-width: 768px) {
  .dropdown-menu img {
    max-width: 50px; 
  }
}

.dropdown-menu-x::-webkit-scrollbar {
  height: 8px;
}

.dropdown-menu-x::-webkit-scrollbar-thumb {
  background-color: #666; 
  border-radius: 10px; 
}

.dropdown-menu-x::-webkit-scrollbar-track {
  background-color: #f0f0f0; 
}

</style>

<style>
    .aligner {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }
    .dropdown-menu-x {
      flex-direction: row;
      overflow-x: auto;
      white-space: nowrap;
      padding: 0.5rem 0;
    }
    .dropdown-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
    }
    @media (max-width: 768px) {
      .dropdown-menu img {
        max-width: 50px;
      }
    }
    .dropdown-menu-x::-webkit-scrollbar {
      height: 8px;
    }
    .dropdown-menu-x::-webkit-scrollbar-thumb {
      background-color: #666;
      border-radius: 10px;
    }
    .dropdown-menu-x::-webkit-scrollbar-track {
      background-color: #f0f0f0;
    }
</style> -->
</head>
<body>
    <div id="topCanvasContainer">
        <canvas id="resultCanvas"></canvas>
        <canvas id="BalltempCanvas"></canvas>
        <video id="videoElement" autoplay></video>
        <img id="resultImg">
    </div>
    <div>
        <canvas id="court_canvas"></canvas>
        <div id="CourtDisplay">
            <canvas id="copy_canvas"></canvas>
        </div>
    </div>
    <div class="aligner" id="selectCourt">
    <div class="container mt-5" style="z-index: 100; position: relative;">
        <div class="dropdown">
          <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
            选择球场
          </button>
          <div class="dropdown-menu dropdown-menu-x">
            <div class="d-flex">
                <div class="dropdown-item" data-value="0court.png">
                    <img src="./static/0court.png" alt="Image 1" class="img-thumbnail me-3">
                  </div>
                  <div class="dropdown-item" data-value="1court.png">
                    <img src="./static/1court.png" alt="Image 2" class="img-thumbnail me-3">
                  </div>
                  <div class="dropdown-item" data-value="2court.png">
                    <img src="./static/2court.png" alt="Image 3" class="img-thumbnail me-3">
                  </div>
                  <div class="dropdown-item" data-value="250court.png">
                    <img src="./static/250court.png" alt="Image 4" class="img-thumbnail me-3">
                  </div>
              <!-- 可以添加更多的下拉项 -->
            </div>
          </div>
        </div>
      </div>
    </div>
      <div id="bottomControls" class="container">
        <!-- 卡片组件开始 -->
        <div class="row">
          <div class="col-md-6">
            <div class="card">
              <div class="card-header">
                文件上传与模式选择
              </div>
              <div class="card-body">
                <!-- 文件上传 -->
                <div class="mb-3">
                  <input type="file" class="form-control" id="fileInput" accept=".mp4,.mov">
                </div>
                <!-- 模式切换按钮 -->
                <div class="mb-3">
                  <button type="button" class="btn btn-primary me-2" id="realTimeModeButton">实时模式</button>
                  <button type="button" class="btn btn-primary" id="postProcessingModeButton">后处理模式</button>
                </div>
                <!-- 录制控制按钮 -->
                <div class="mb-3">
                  <button type="button" class="btn btn-primary me-2" id="startButtonFile">开始录制</button>
                  <button type="button" class="btn btn-danger" id="stopButtonFile" disabled>停止录制</button>
                </div>
                <!-- 关键点定位按钮 -->
                <div class="mb-3">
                  <button type="button" class="btn btn-primary me-2" id="locatePoints">重新选择球场</button>
                  <button type="button" class="btn btn-danger" id="EndlocatePoints" disabled>关键点定位结束</button>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="card">
              <div class="card-header">
                录制控制与设置
              </div>
              <div class="card-body">
                <!-- 录制控制按钮 -->
                <div class="mb-3">
                  <button type="button" class="btn btn-primary me-2" id="startButton">开始录制</button>
                  <button type="button" class="btn btn-danger" id="stopButton" disabled>停止录制</button>
                </div>
                <!-- 跳转帧选项 -->
                <div class="form-check mb-3">
                  <input class="form-check-input" type="checkbox" value="" id="jumpFrame">
                  <label class="form-check-label" for="jumpFrame">跳转帧</label>
                </div>
                <!-- 跳转帧说明 -->
                <div id="jumptext" class="mb-3 text-muted">选择跳转帧以加快视频处理速度。</div>
                <!-- FPS设置 -->
                <div class="mb-3">
                  <label for="fpsDelayInput" class="form-label">FPS</label>
                  <input type="number" class="form-control" id="fpsDelayInput" value="15">
                  <button type="button" class="btn btn-primary mt-2" id="updateFpsDelayButton">更新</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- 卡片组件结束 -->
      </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.min.js"></script>
    <script>
        // 你的JavaScript代码放在这里
        let videoStream;
        let audioStream;
        let audio_mediaRecorder;
        let mediaSource;
        let sourceBuffer;
        // let vidio_mediaRecorder;
        let dingshi;
        let jump=false;
        let jpcount=0;
        let audioChunks = [];
        let audioContext;
        let mediaRecorder;
        let width;
        let height;
        let resetCanvasSize=1;
        let all_frame=[];
        let frameCount=0;
        let originTime=Date.now();
        let lastFrame=Date.now();
        let ct1,ct2,ct3;
        let worker = new Worker('static/worker.js');
        let uniqueIdentifier;
        let points=[];

        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const startButtonFile = document.getElementById('startButtonFile');
        const stopButtonFile= document.getElementById('stopButtonFile');
        var resultCanvas = document.getElementById("resultCanvas");
        var resultContext = resultCanvas.getContext("2d");
        var BalltempCanvas = document.getElementById("BalltempCanvas");
        var BalltempContext = BalltempCanvas.getContext("2d");
        const video = document.getElementById("videoElement");
        const jumpFrame = document.getElementById("jumpFrame");
        const jumptext=document.getElementById("jumptext");

        let fileInput = document.getElementById('fileInput');
        const topCanvasContainer = document.getElementById('topCanvasContainer');
        const bottomControls = document.getElementById('bottomControls');
        const blobURLPattern = /blob:(.*\/)([a-zA-Z0-9\-]+)$/; // 更精确的正则表达式
        const imgElement=document.getElementById('resultImg');
        const realTimeModeButton=document.getElementById('realTimeModeButton');
        const postProcessingModeButton=document.getElementById('postProcessingModeButton');
        let tempCanvas=document.createElement("canvas");
        let tempContext=tempCanvas.getContext("2d");
        let timer; // 用于存储定时器引用
        let fps=15;
        // let points_and_time=[];
        var player=undefined;
        var ball_r=0;
        let temp_point=[];
        let keypoints=[];
        // 设置初始时间
        var minutes = 0;
        var seconds = 0;
        var makes=0;
        var attempts=0;
        var shooting_balls=[];
        let ball_trace_r=undefined;
        let pre_ball_state='normal';
        var leftFoot=undefined;
        var rightFoot=undefined;
        var playerStand=undefined;

        const locatePoints=document.getElementById("locatePoints");
        const EndlocatePoints=document.getElementById("EndlocatePoints");
        var selectCourt=document.getElementById('selectCourt');
        // 使用document.getElementById获取下拉菜单按钮的DOM元素
        locatePoints.addEventListener("click", () => {
            // 模拟点击选择框来弹出选项
            selectCourt.style.display='flex';
            // let dropdownToggle = document.getElementById('dropdownMenuButton');
            // dropdownToggle.click();

            });
        EndlocatePoints.addEventListener('click',()=>{
            court_canvas.style.display='none';
        })

        // 获取元素
        const fpsDelayInput = document.getElementById('fpsDelayInput');
        const updateFpsDelayButton = document.getElementById('updateFpsDelayButton');

        let updateCountdownTimer=undefined;
        function updateCountdown() {
            var countdownElement = document.getElementById('Time');
            seconds++;
                // 如果秒数为负数，则减少分钟，并将秒数重置为 59
                if (seconds == 60) {
                    minutes++;
                    seconds = 0;
                }
                // 格式化时间，并更新到页面上
                countdownElement.innerHTML = (minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
                // 每秒调用一次更新倒计时函数
                updateCountdownTimer=setTimeout(updateCountdown, 1000);
        }

        // 添加点击事件监听器
        updateFpsDelayButton.addEventListener('click', function() {
            // 获取输入框中的值并转换为整数
            const newFpsDelay = parseInt(fpsDelayInput.value);
            
            // 更新 fps_delay 变量的值
            fps = newFpsDelay;
            
            // 可以在这里执行任何其他相关的操作
            console.log('FPS Delay updated to:', fps);
        });

        startButtonFile.addEventListener('click',async () =>{
            ct1=0,ct2=0,ct3=0;
            capCost=0;
            frameCount=0;
            resetCanvasSize=1;
            let file = fileInput.files[0];
            let videoURL = URL.createObjectURL(file);
            video.src = videoURL;

            const formData = new FormData();
            formData.append('mp4File', file);

            try {
                const response = await fetch('/upload_mp4', {
                    method: 'POST',
                    body: formData
                });
            } catch (error) {
                console.error('Error uploading file:', error);
                alert('Error uploading file.');
            }
            startButtonFile.disabled = true;
            stopButtonFile.disabled = false;
        })
        stopButtonFile.addEventListener('click',async () =>{
            clearInterval(dingshi); // 停止发送帧数据
            startButtonFile.disabled = false; // 启用开始录制按钮
            stopButtonFile.disabled = true; // 禁用停止录制按钮
            const formData = new FormData();
                // formData.append('audio', blob, 'audio.wav');
                formData.append('isFromCamera',false);
                formData.append('imgWidth',width);
                formData.append('imgHeight',height);
                formData.append('fps',fps);
                await fetch('/upload', {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    window.location.href='/afterShooting'+'?uuid='+uniqueIdentifier+'&court_img='+court_img;
                })
                .catch(error => {
                    console.error('Error:', error);
                });;;
                video.pause();
                console.log(frameCount);
        })

        function EveryFrame(){
            let ct0=Date.now();
            let ct00=Date.now();
            // while(ct0-lastFrame<(1000/fps)){
            //     ct0=Date.now();
            // }
            if((1000/fps)-(ct0-lastFrame)>=10){
                dingshi=setTimeout(EveryFrame,9);
                return;
            }
            else{
                while(ct0-lastFrame<(1000/fps)){
                    ct0=Date.now();
                }
            }
            ct1=ct0-lastFrame;
            lastFrame=Date.now();
            // console.log('frame gap',ct1,"cap",ct2,"send",ct3,"wait",lastFrame-ct00);
            const {imageData,imageWidth,imageHeight} = captureFrame(video);
            ct2=Date.now()-lastFrame;
            temp=Date.now();
            // all_frame.push(imageData);
            sendData(imageData,imageWidth,imageHeight,false);
            ct3=Date.now()-temp;
            
            dingshi=setTimeout(EveryFrame,0);
        }
        
        function canvas_n2canvas_XY(nx,ny){
            let x = nx*resultCanvas.width;
            let y = ny*resultCanvas.height;
            return {x:x,y:y};         
        }
        function canvas_n2window_XY(nx,ny){
            const rect = resultCanvas.getBoundingClientRect();
            let realVideo={};
            if (resultCanvas.height*rect.width>resultCanvas.width*rect.height){
                realVideo.height=rect.height;
                realVideo.width=realVideo.height*(resultCanvas.width/resultCanvas.height);
            }
            else{
                realVideo.width=rect.width;
                realVideo.height=realVideo.width*(resultCanvas.height/resultCanvas.width);
            }
            realVideo.left=(rect.width-realVideo.width)*0.5;
            realVideo.top=(rect.height-realVideo.height)*0.5;
            // let scale=resultCanvas.width/realVideo.width;
            let x = nx*realVideo.width+realVideo.left;
            let y = ny*realVideo.height+realVideo.top;
            return {x:x,y:y}; 
        }

        function canvas2window_XY(cx,cy){
            const rect = resultCanvas.getBoundingClientRect();
            let realVideo={};
            if (resultCanvas.height*rect.width>resultCanvas.width*rect.height){
                realVideo.height=rect.height;
                realVideo.width=realVideo.height*(resultCanvas.width/resultCanvas.height);
            }
            else{
                realVideo.width=rect.width;
                realVideo.height=realVideo.width*(resultCanvas.height/resultCanvas.width);
            }
            realVideo.left=(rect.width-realVideo.width)*0.5;
            realVideo.top=(rect.height-realVideo.height)*0.5;
            let scale=resultCanvas.width/realVideo.width;
            let x = cx/scale + realVideo.left;
            let y = cy/scale + realVideo.top;
            return {x:x,y:y};            
        }

        function window2canvas_XY(wx,wy){
            const rect = resultCanvas.getBoundingClientRect();
            let realVideo={};
            if (resultCanvas.height*rect.width>resultCanvas.width*rect.height){
                realVideo.height=rect.height;
                realVideo.width=realVideo.height*(resultCanvas.width/resultCanvas.height);
            }
            else{
                realVideo.width=rect.width;
                realVideo.height=realVideo.width*(resultCanvas.height/resultCanvas.width);
            }
            realVideo.left=(rect.width-realVideo.width)*0.5;
            realVideo.top=(rect.height-realVideo.height)*0.5;
            let scale=resultCanvas.width/realVideo.width;
            let x = (wx - realVideo.left)*scale;
            let y = (wy - realVideo.top)*scale;
            return {x:x,y:y};
            
        }
        function canvas_n2court_XY(nx,ny){
            let windowPoint=canvas_n2window_XY(nx,ny);
            const rect = court_canvas.getBoundingClientRect();
            const x = windowPoint.x - rect.left;
            const y = windowPoint.y - rect.top;
            return {x:x,y:y};

        }
        function canvas_n2right_court_XY(nx,ny,score=true){
            let courtPoint=canvas_n2court_XY(nx,ny);

            let input_point = [[courtPoint.x], [courtPoint.y], [1]];
            let output_point;
            if (ipm) {
                output_point = dot(ipm, input_point);
                output_point[0] /= output_point[2];
                output_point[1] /= output_point[2];
                let copy_x=(output_point[0] - court_x) / (court_canvas.width - 2 * court_x);
                let copy_y=(output_point[1] - court_y) / (court_canvas.height - 2 * court_y);
                //不超出范围
                let radus=10;
                let minX=radus/copy_canvas.width;
                let minY=radus/copy_canvas.height;
                copy_x = Math.max(minX, Math.min(copy_x, 1));
                copy_y = Math.max(minY, Math.min(copy_y, 1));
                if (score){
                    drawPoint_nXY_O(
                    {
                        x: copy_x,
                        y:copy_y,
                    },
                    "green",
                    copy_ctx,
                    copy_canvas,
                    radus
                );
                }else{
                    drawPoint_nXY_X(
                    {
                        x: copy_x,
                        y:copy_y,
                    },
                    "red",
                    copy_ctx,
                    copy_canvas,
                    radus
                );
                }

                console.log(output_point);
            }
        }


        video.addEventListener('play',() =>{
            let match = blobURLPattern.exec(video.src);
            if (match) {
                 uniqueIdentifier = match[2];
                console.log(uniqueIdentifier); // 这里就是提取到的唯一标识符
            } else {
                uniqueIdentifier = Math.random().toString(36).substr(2, 9);
                console.error('Failed to extract unique identifier from video src.');
                console.log(uniqueIdentifier)
            }
            originTime=Date.now();
            EveryFrame();
            // bottomControls.style.display = 'none';
            const scoreDisplayDiv=document.querySelectorAll('#scoreDisplay');
            if (scoreDisplayDiv.length<1){
                const scoreDisplay=document.createElement("div");
                scoreDisplay.setAttribute('id',"scoreDisplay");
                scoreDisplay.innerHTML=`<span class="spanLeftRight">
                <span class="scoreNum" id="makes">${makes}</span>
                <span class="underScoreNumText">MAKES</span>
                </span>
                    <span class="xie">/</span>
                <span >
                    <span class="scoreNum" id="attempts">${attempts}</span>
                    <span class="underScoreNumText">ATTEMPTS</span>
                </span>`;
                let left_top=canvas_n2window_XY(0,0);
                let right_bottom=canvas_n2window_XY(1,1);
                let width=right_bottom.x-left_top.x;
                let height=right_bottom.y-left_top.y;
                scoreDisplay.style.setProperty('--canvasLeft',left_top.x+'px');
                scoreDisplay.style.setProperty('--canvasTop',left_top.y+'px');
                scoreDisplay.style.setProperty('--canvasWidth',width+'px');
                scoreDisplay.style.setProperty('--canvasHeight',height+'px');
                console.log("scoreDisplay",left_top.x,left_top.y);
                topCanvasContainer.appendChild(scoreDisplay);

                // 获取屏幕的宽度和高度
                const screenWidth = window.innerWidth;
                const xieElement = document.querySelector('.xie');
                const xieRect = xieElement.getBoundingClientRect();
                const xieCenterX = xieRect.left + xieRect.width / 2;
                // 计算偏移量
                const offsetX = screenWidth / 2 - xieCenterX;
                scoreDisplay.style.transform = `translate(${offsetX}px)`;

            }

            const TimeDisplayDiv=document.querySelectorAll('#TimeDisplay');
            if (TimeDisplayDiv.length<1){
                const TimeDisplay=document.createElement("div");
                const TimeSpan=document.createElement("span");
                TimeDisplay.setAttribute('id',"TimeDisplay");
                TimeSpan.setAttribute('id','Time');

                TimeSpan.innerHTML='00:00';
                TimeDisplay.appendChild(TimeSpan);
                let left_top=canvas_n2window_XY(0,0);
                let right_bottom=canvas_n2window_XY(1,1);
                let width=right_bottom.x-left_top.x;
                let height=right_bottom.y-left_top.y;
                TimeDisplay.style.setProperty('--canvasLeft',left_top.x+'px');
                TimeDisplay.style.setProperty('--canvasTop',left_top.y+'px');
                TimeDisplay.style.setProperty('--canvasWidth',width+'px');
                TimeDisplay.style.setProperty('--canvasHeight',height+'px');
                console.log("TimeDisplay",left_top.x,left_top.y);
                topCanvasContainer.appendChild(TimeDisplay);
                // setTimeout(updateCountdown(),500);
                updateCountdown();
            }

            const CourtDisplayDiv=document.querySelectorAll('#CourtDisplay');
            if (CourtDisplayDiv.length==1){
                const CourtDisplay=document.getElementById('CourtDisplay')
                // CourtDisplay.setAttribute('id',"CourtDisplay");

                let left_top=canvas_n2window_XY(0,0);
                let right_bottom=canvas_n2window_XY(1,1);
                let width=right_bottom.x-left_top.x;
                let height=right_bottom.y-left_top.y;
                CourtDisplay.style.setProperty('--canvasLeft',left_top.x+'px');
                CourtDisplay.style.setProperty('--canvasTop',left_top.y+'px');
                CourtDisplay.style.setProperty('--canvasWidth',width+'px');
                CourtDisplay.style.setProperty('--canvasHeight',height+'px');
                const courtCanvas = document.getElementById('copy_canvas');
                const currentWidth = courtCanvas.width; // 获取当前宽度
                const currentHeight = courtCanvas.height; // 获取当前高度
                const targetWidth = width * 0.195; // 目标宽度
                const scale = targetWidth / currentWidth; // 计算缩放比例
                const targetHeight = currentHeight * scale; // 根据比例计算目标高度

                // 设置新的宽度和高度
                courtCanvas.style.width = targetWidth + 'px';
                courtCanvas.style.height = targetHeight + 'px';
                
            }

        })

        video.addEventListener('ended', async () => {
            bottomControls.style.display = 'block';
            console.log('all frame',frameCount,Date.now()-originTime);
            clearTimeout(dingshi);
            clearTimeout(updateCountdownTimer);
            // clearTimeout(generate_timeout);
            // clearTimeout(timer_runBar);
            startButtonFile.disabled = false; // 启用开始录制按钮
            stopButtonFile.disabled = true; // 禁用停止录制按钮
            const formData = new FormData();
                // formData.append('audio', blob, 'audio.wav');
                formData.append('isFromCamera',false);
                formData.append('imgWidth',width);
                formData.append('imgHeight',height);
                formData.append('uuid',uniqueIdentifier)
                formData.append('fps',fps);
                await fetch('/upload', {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    window.location.href='/afterShooting'+'?uuid='+uniqueIdentifier+'&court_img='+court_img;
                })
                .catch(error => {
                    console.error('Error:', error);
                });;
                // console.log(points_and_time);
        });

        startButton.addEventListener('click', async () => {
            resetCanvasSize=1;
            videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            video.srcObject = videoStream;

            audio_mediaRecorder = new MediaRecorder(audioStream);
            audio_mediaRecorder.addEventListener('dataavailable', event => {
                audioChunks.push(event.data);
                console.log("这",event.data);
            });
            audio_mediaRecorder.addEventListener('stop', async () => {
                const blob = new Blob(audioChunks, { type: 'audio/wav' });
                const formData = new FormData();
                formData.append('audio', blob, 'audio.wav');
                formData.append('isFromCamera',true);
                formData.append('imgWidth',width);
                formData.append('imgHeight',height);
                formData.append('uuid',uniqueIdentifier);
                formData.append('fps',fps);
                await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                //一定要清空！！！
                audioChunks=[];
            });

            audio_mediaRecorder.start();

            startButton.disabled = true;
            stopButton.disabled = false;

        });

        stopButton.addEventListener('click', () => {
            audio_mediaRecorder.stop();
            clearTimeout(dingshi);
            videoStream.getTracks().forEach(track => track.stop());
            audioStream.getTracks().forEach(track => track.stop());
            startButton.disabled = false;
            stopButton.disabled = true;

        });

        jumpFrame.addEventListener("click", () => {
            jump=!jump;
            jumptext.innerText=jump;

        });   

        function captureFrame(video) {
            frameCount++;

            // const canvas = document.createElement("canvas");
            const maxWidth = 640;
            const maxHeight = 640;
            width = video.videoWidth;
            height = video.videoHeight;
            if(resetCanvasSize){
                resultCanvas.width=width;
                resultCanvas.height=height;
                resetCanvasSize=0;
                BalltempCanvas.width = width;
                BalltempCanvas.height = height;

            }

            // 如果视频的宽度或高度大于最大宽度或高度，进行等比例缩放
            if (width > maxWidth || height > maxHeight) {
                const aspectRatio = width / height;
                if (aspectRatio > 1) {
                    // 宽度大于高度，按照宽度进行缩放
                    width = maxWidth;
                    height = maxWidth / aspectRatio;
                } else {
                    // 高度大于宽度，按照高度进行缩放
                    height = maxHeight;
                    width = maxHeight * aspectRatio;
                }
            }
            //得是偶数
            width=width-width%2
            height=height-height%2

            tempCanvas.width = width;
            tempCanvas.height = height;
            // for(let obj of points_and_time){
            //     if (obj.frame==frameCount){
            //         resultContext.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            //         for(let p of obj.points){
            //             resultContext.beginPath();
            //             resultContext.arc(p[0], p[1], 80, 0, 2 * Math.PI);
            //             resultContext.fillStyle = 'red';
            //             resultContext.fill();
            //         }
            //     }
            // }
            tempContext.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            
                            // 在这里应用水平翻转
    // tempContext.save(); // 保存当前绘图状态
    // tempContext.scale(-1, 1); // 水平翻转
    // tempContext.drawImage(video, -tempCanvas.width, 0, tempCanvas.width, tempCanvas.height); // 绘制翻转后的视频帧
    // tempContext.restore(); // 恢复绘图状态

            let data=tempCanvas.toDataURL("image/jpeg");
            return {
                imageData:data,
                imageWidth:width,
                imageHeight:height
            }
        }
        function calculateDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }
// 多项式拟合
function polynomialFit(x, y, degree) {
    // 构建系数矩阵
    const X = [];
    for (let i = 0; i < x.length; i++) {
        let row = [];
        for (let j = 0; j <= degree; j++) {
            row.push(Math.pow(x[i], j));
        }
        X.push(row);
    }

    // 计算系数
    const Xt = numeric.transpose(X);
    const XtX = numeric.dot(Xt, X);
    const XtY = numeric.dot(Xt, y);
    const coefficients = numeric.solve(XtX, XtY);

    // 生成拟合曲线
    const fittedPoints = [];

    for (let xi = x[0];;) {
        let yFit = 0;
        for (let j = 0; j <= degree; j++) {
            yFit += coefficients[j] * Math.pow(xi, j);
        }
        fittedPoints.push({ x: xi, y: yFit });
        if(x[0]<x[x.length-1]){
            xi+=2;
            if(xi>x[x.length-1]){
                break;
            }
        }
        else{
            xi-=2;
            if(xi<x[x.length-1]){
                break;
            }
        }
    }

    return fittedPoints;
}

      // 发送数据到服务器
        function sendData(imageData,imageWidth,imageHeight,flipFrame) {
        if(jump){
            jpcount++;
        }
        else{
            jpcount=1;
        }
        fetch("/process_frame", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ 
            image_data: imageData,
            jumpORnot:jpcount%2,
            imgWidth:imageWidth,
            imgHeight:imageHeight,
            imgFlip:flipFrame,
            uuid:uniqueIdentifier
        }),
        })
          .then((response) => response.json())
          .then((data) => {
            if(resultCanvas.width==0 || resultCanvas.height==0){
                resultCanvas.width=video.videoWidth;
                resultCanvas.height=video.videoHeight;
            }
            if(video.style.zIndex<imgElement.style.zIndex || video.style.zIndex<resultCanvas.style.zIndex){
                imgElement.src = "data:image/jpeg;base64," + data.image_data;

                let extra_data=data.extra_data;
                if(extra_data.player.length>=1){
                    player=extra_data.player[0];
                }
                if(extra_data.coordinates.length>=1){
                    keypoints=extra_data.coordinates[0];
                    let left_hand=canvas_n2window_XY(keypoints[9][0],keypoints[9][1]);
                    let right_hand=canvas_n2window_XY(keypoints[10][0],keypoints[10][1]);

                    const existingSVGs = document.querySelectorAll('.progress-circle');
                    for(let div of existingSVGs){
                        const svg = div.querySelector('svg');
                        let center=getSvgCenter(svg);
                        let svg_r = svg.getBoundingClientRect().width/2.0;
                        let offset=60;
                        if(calculateDistance(center.x, center.y, left_hand.x, left_hand.y) < offset+svg_r || calculateDistance(center.x, center.y, right_hand.x, right_hand.y) < offset+svg_r){
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                                });
                            svg.dispatchEvent(clickEvent);
                        }
                    }  
                }
                if (extra_data.ball.length>=1){
                    let ball=extra_data.ball[0];
                    let bp1=canvas_n2canvas_XY(ball[0],ball[1]);
                    let bp2=canvas_n2canvas_XY(ball[2],ball[3]);
                    let cx,cy;
                    cx=(bp1.x+bp2.x)/2.0;
                    cy=(bp1.y+bp2.y)/2.0;
                    ball_r = (bp2.x-bp1.x)/2.0;
                    if (extra_data.ball_state=='shooting'){
                        shooting_balls.push({x:cx,y:cy});
                        if(shooting_balls.length==1){
                            ball_trace_r=ball_r;
                            // if(keypoints){
                            //     console.log("player",keypoints)
                            //     leftFoot=keypoints[15];
                            //     rightFoot=keypoints[16];
                            //     console.log("left right",leftFoot,rightFoot);
                            //     let playerStand={x:(leftFoot[0]+rightFoot[0])/2,y:(leftFoot[1]+rightFoot[1])/2};
                            //     console.log("stand",playerStand);
                            //     let windowStand=canvas_n2canvas_XY(playerStand.x,playerStand.y);
                            //     drawPoint(windowStand,'red',resultContext,20);
                            //     canvas_n2right_court_XY(playerStand.x,playerStand.y);
                            // }
                            if(player){
                                leftFoot=[player[0],player[3]];
                                rightFoot=[player[2],player[3]];
                                console.log("left right",leftFoot,rightFoot);
                                playerStand={x:(leftFoot[0]+rightFoot[0])/2,y:(leftFoot[1]+rightFoot[1])/2};

                                console.log("stand",playerStand);
                                let windowStand=canvas_n2canvas_XY(playerStand.x,playerStand.y);
                                drawPoint(windowStand,'red',resultContext,20);
                                // canvas_n2right_court_XY(playerStand.x,playerStand.y);
                                // console.log(player);
                            }

                        }
                        //加上距离判断，过于离谱的点就不画
                        if(shooting_balls.length>2 ){
                            // 创建一个矩阵
                            BalltempContext.clearRect(0, 0, BalltempCanvas.width, BalltempCanvas.height);

                            // 降低透明度来清除画布
                            // let points = shooting_balls;
                            const degree = 3; // 多项式次数
                            let points = polynomialFit(shooting_balls.map(point => point.x), shooting_balls.map(point => point.y), degree);
                            // 定义颜色渐变
                            // const gradient = BalltempContext.createLinearGradient(0, 0, BalltempCanvas.width, 0);
                            // gradient.addColorStop(0, 'blue'); // 蓝色
                            // gradient.addColorStop(0.5, 'cyan'); // 青色
                            // gradient.addColorStop(1, 'magenta'); // 洋红色
                            // // 设置线条样式
                            // BalltempContext.lineCap = 'round';
                            // BalltempContext.lineJoin = 'round';
                            // BalltempContext.strokeStyle = gradient;
                            // 创建线性渐变，从左到右

                            // 设置线条样式
                            BalltempContext.lineCap = 'round';
                            BalltempContext.lineJoin = 'round';
                            BalltempContext.strokeStyle = 'white';
                            // 增加阴影效果
                            BalltempContext.shadowColor = 'rgba(255, 255, 255, 0.5)'; // 白色阴影
                            BalltempContext.shadowBlur = 3; // 模糊半径
                            BalltempContext.shadowOffsetX = 0; // 阴影在水平方向上的偏移量
                            BalltempContext.shadowOffsetY = 0; // 阴影在垂直方向上的偏移量

                            // 计算初始线宽和每步减少的线宽
                            let initialLineWidth=20;
                            if (ball_trace_r!=undefined){
                                initialLineWidth=ball_trace_r*0.5;
                            }
                            let lineWidthStep = initialLineWidth / points.length;
                            // 绘制平滑曲线
                            BalltempContext.lineWidth = initialLineWidth;
                            // 使用新的点数组绘制平滑曲线
                            BalltempContext.beginPath();
                            BalltempContext.moveTo(points[0].x, points[0].y);
                            for (let i = 1; i < points.length - 2; i++) {
                                    const xc1 = (points[i].x + points[i + 1].x) / 2;
                                    const yc1 = (points[i].y + points[i + 1].y) / 2;
                                    const xc2 = (points[i + 1].x + points[i + 2].x) / 2;
                                    const yc2 = (points[i + 1].y + points[i + 2].y) / 2;

                                    BalltempContext.lineWidth -= lineWidthStep;
                                    if (BalltempContext.lineWidth < 1) {
                                        BalltempContext.lineWidth = 1;
                                    }

                                    BalltempContext.quadraticCurveTo(points[i].x, points[i].y, xc1, yc1);
                                    if(i%2==0){
                                        BalltempContext.stroke();
                                    }
                            }
                                // 使用最后一个点绘制最后一段曲线
                                BalltempContext.quadraticCurveTo(
                                    points[points.length - 2].x,
                                    points[points.length - 2].y,
                                    points[points.length - 1].x,
                                    points[points.length - 1].y
                                );
                            // 绘制样式
                            BalltempContext.stroke();
                        }
                    }
                    else{
                        if(shooting_balls.length>0){
                            shooting_balls=[];
                            resultContext.globalAlpha = 0.85; // 设置透明度为 0.5，值在 0 到 1 之间
                            resultContext.drawImage(BalltempCanvas, 0, 0);
                            resultContext.globalAlpha = 1; // 恢复默认的透明度为 1
                        }
                    }
                    //忘记score会直接加了
                    if(extra_data.ball_state!='Judging' && pre_ball_state=='Judging'){
                        let makesSpan=document.getElementById('makes');
                        let attemptsSpan=document.getElementById('attempts');
                        setTimeout(() => {
                            makesSpan.style.transition='transform 0.2s ease-out';
                            makesSpan.style.transform = 'scale(1.5)';
                            setTimeout(()=>{
                                makesSpan.style.transform = 'scale(1)'; 
                            },200)
                            attemptsSpan.style.transition='transform 0.2s ease-out';
                            attemptsSpan.style.transform = 'scale(1.5)';
                            setTimeout(()=>{
                                attemptsSpan.style.transform = 'scale(1)'; 
                            },200)
                        }, 50);

                        canvas_n2right_court_XY(playerStand.x,playerStand.y,makesSpan.innerHTML!=extra_data.score_count);
                        makesSpan.innerHTML=extra_data.score_count;
                        attemptsSpan.innerHTML=extra_data.shooting_count;
                        
                    }
                    pre_ball_state=extra_data.ball_state;
                }

            }
            

            // console.log(player);
            })
          .catch((error) => {
            console.error("Error sending data to server: ", error);
            // alert("An error occurred while processing the frame. Please try again later.");
          });
      }

        bottomControls.addEventListener('click',()=>{
            if (timer) {
                    clearTimeout(timer);
                }
        })

        // 点击 #topCanvasContainer 时触发的函数
        topCanvasContainer.addEventListener('click', () => {
            // 显示 #bottomControls
            if (bottomControls.style.display==='block'){
                bottomControls.style.display='none';
            }
            else{
                bottomControls.style.display = 'block';
                            // 如果之前已经设置了定时器，则清除之前的定时器
                if (timer) {
                    clearTimeout(timer);
                }
                // 设置一个定时器，在 6 秒后隐藏 #bottomControls
                timer = setTimeout(() => {
                    bottomControls.style.display = 'none';
                }, 3000);
            }
        });
        
        realTimeModeButton.addEventListener('click',() =>{
            video.style.zIndex="5";
            resultCanvas.style.zIndex="7";
            BalltempCanvas.style.zIndex="8";
            imgElement.style.zIndex="6";
        })
        postProcessingModeButton.addEventListener('click',() =>{
            video.style.zIndex="6";
            resultCanvas.style.zIndex="7";
            BalltempCanvas.style.zIndex="8";
            imgElement.style.zIndex="5";

        })
    </script>
    <script>

        function getSvgCenter(svg) {
            const rect = svg.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            return { x: centerX, y: centerY };
        }

    </script>
            <script>
                // 定义一些全局变量
                let court_canvas,
                    court_ctx,
                    copy_canvas,
                    copy_ctx,
                    srcImg,
                    dstImg,
                    srcPoints,
                    dstPoints,
                    selectedPoint = -1;
                let canvasWidth, canvasHeight;
                var court_x;
                var court_y;
                var ipm = [
                    [1, 0, 0],
                    [0, 1, 0],
                    [0, 0, 1],
                ];
                let court_img = "1court.png";
                function dot(matrixA, matrixB) {
                    if (matrixA[0].length !== matrixB.length) {
                        throw "矩阵尺寸不兼容";
                    }
    
                    var result = [];
                    for (var i = 0; i < matrixA.length; i++) {
                        result[i] = [];
                        for (var j = 0; j < matrixB[0].length; j++) {
                            var sum = 0;
                            for (var k = 0; k < matrixA[0].length; k++) {
                                sum += matrixA[i][k] * matrixB[k][j];
                            }
                            result[i][j] = sum;
                        }
                    }
                    return result;
                }
                                    // 获取所有的下拉菜单项
                    const dropdownItems = document.querySelectorAll('.dropdown-item');
                    var dropdownToggle = document.getElementById('dropdownMenuButton');

                    // 为每个下拉菜单项添加点击事件监听器
                    dropdownItems.forEach(item => {
                    item.addEventListener('click', function() {
                        // 获取当前点击的下拉菜单项的data-value属性
                        const selectedImage = this.getAttribute('data-value');
                        court_img = selectedImage;
                        // TODO: 使用selectedImage做一些操作，比如更新页面上的某个元素或变量
                        console.log(selectedImage);
                        initCanvas()
                        
                        // 关闭下拉菜单
                        
                        dropdownToggle.click();
                        selectCourt=document.getElementById('selectCourt');
                        // console.log(selectCourt);
                        selectCourt.style.display='none';

                    });
                    });
 
                    

                // 初始化Canvas和图像
                function initCanvas() {
                    court_canvas = document.getElementById("court_canvas");
                    court_ctx = court_canvas.getContext("2d");
                    copy_canvas = document.getElementById("copy_canvas");
                    copy_ctx = copy_canvas.getContext("2d");
                    // 创建一个新的 Canvas 元素
                    var newCanvas = document.createElement("canvas");
                    var newCtx = newCanvas.getContext("2d");
    
                    // 设置新的 Canvas 的长宽为满屏幕大小
                    newCanvas.width = window.innerWidth;
                    newCanvas.height = window.innerHeight;
    
                    srcImg = new Image();
                    srcImg.onload = () => {
                        // copy_canvas.width = srcImg.width * 0.5;
                        // copy_canvas.height = srcImg.height * 0.5;
                        // 假设 `srcImg` 是原始图像的引用
                        
                        var screen_width = window.innerWidth; // 获取当前屏幕的宽度
                        var scale_factor = screen_width / 5; // 设置宽度为屏幕宽度的1/5
                        // 计算等比例缩放的宽度和高度
                        copy_canvas.width = srcImg.width * (scale_factor / srcImg.width);
                        copy_canvas.height = srcImg.height * (scale_factor / srcImg.height);

                        // 创建临时 Canvas
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');

                        // 设置临时 Canvas 的大小和原图一样
                        tempCanvas.width = copy_canvas.width;
                        tempCanvas.height = copy_canvas.height;

                        // // 应用黑白滤镜
                        // tempCtx.filter = 'grayscale(100%)';
                        // // 将原图绘制到临时 Canvas 上
                        tempCtx.drawImage(srcImg, 0, 0, tempCanvas.width, tempCanvas.height);
                        // 获取图像数据
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        const data = imageData.data;

                        // 设置阈值
                        const threshold = 128; // 可以根据需要调整阈值

                        // 应用阈值法转换图像为黑白
                        for (let i = 0; i < data.length; i += 4) {
                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3; // 计算亮度值
                            const color = brightness > threshold ? 255 : 0; // 根据亮度值设置颜色
                            data[i] = color; // 设置红色通道
                            data[i + 1] = color; // 设置绿色通道
                            data[i + 2] = color; // 设置蓝色通道
                        }

                        // 将处理后的图像数据绘制到 copy_canvas 上
                        tempCtx.putImageData(imageData, 0, 0);

                        //透明度
                        copy_ctx.globalAlpha=0.5;
                        copy_ctx.drawImage(
                            tempCanvas,
                            0,
                            0,
                            copy_canvas.width,
                            copy_canvas.height
                        );
                        copy_ctx.globalAlpha=1;
                        const maxWidth = window.innerWidth;
                        const maxHeight = window.innerHeight;
                        const imageWidth = srcImg.width;
                        const imageHeight = srcImg.height;
                        if (imageWidth / imageHeight > maxWidth / maxHeight) {
                            canvasWidth = maxWidth;
                            canvasHeight = imageHeight * (maxWidth / imageWidth);
                        } else {
                            canvasWidth = imageWidth * (maxHeight / imageHeight);
                            canvasHeight = maxHeight;
                        }
                        // 设置 Canvas 的宽度和高度
                        court_canvas.width = canvasWidth;
                        court_canvas.height = canvasHeight;
                        console.log(canvasWidth, canvasHeight);
    
                        court_ctx.drawImage(srcImg, 0, 0, canvasWidth, canvasHeight);
    
                        // 计算绘制位置，使现有的 Canvas 绘制在新的 Canvas 中间
                        court_x = (newCanvas.width - court_canvas.width) / 2;
                        court_y = (newCanvas.height - court_canvas.height) / 2;
    
                        // 在新的 Canvas 上绘制现有的 Canvas
                        newCtx.drawImage(court_canvas, court_x, court_y);
                        court_canvas.width = newCanvas.width;
                        court_canvas.height = newCanvas.height;
                        court_ctx.clearRect(0, 0, court_canvas.width, court_canvas.height);
                        court_ctx.drawImage(newCanvas, 0, 0);
                        var dataUrl = court_canvas.toDataURL("image/jpeg");
                        // 发送数据到后端保存
                        fetch("/save_image", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ image_data: dataUrl }),
                        })
                            .then((response) => response.json())
                            .then((data) => {
                                console.log("Image saved successfully:", data);
                            })
                            .catch((error) => {
                                console.error("Error saving image:", error);
                            });
                        resetPoints();
                    };
                    srcImg.src = "static/" + court_img; // 替换为你的图像路径
                }
    
                // 重置映射点到默认位置
                function resetPoints() {
                    srcPoints = [
                        // { x: 0, y: 0 },
                        // { x: canvas.width, y: 0 },
                        // { x: canvas.width, y: canvas.height },
                        // { x: 0, y: canvas.height }
                    ];
                    dstPoints = [
                        // { x: 0, y: 0 },
                        // { x: canvas.width , y: 0 },
                        // { x: canvas.width , y: canvas.height    },
                        // { x: 0, y: canvas.height    }
                    ];
                }
    
                // 绘制场景
                function drawScene() {
                    applyPerspectiveTransform();
                    drawPoints();
                }
    
                // 绘制映射点
                function drawPoints() {
                    for (let i = 0; i < dstPoints.length; i++) {
                        drawPoint(dstPoints[i], selectedPoint === i ? "red" : "yellow");
                    }
                }
    
                // 绘制单个点
                function drawPoint(point, color, context = court_ctx, radus = 20, alpha = 0.3) {
                    context.globalAlpha = alpha;
                    context.beginPath();
                    context.arc(point.x, point.y, radus, 0, 2 * Math.PI);
                    context.fillStyle = color;
                    context.fill();
                    context.closePath();
                    context.globalAlpha = 1;
                }
    
                function drawPoint_nXY_O(point, color, dstContext = copy_ctx, dstCanvas = copy_canvas, radius = 20, alpha = 0.3) {
                // 计算内外圆的半径
                const outerRadius = radius ; // 外圆半径比内圆半径大2个像素
                const innerRadius = radius-4;

                // 绘制外圆（白色）
                dstContext.beginPath();
                dstContext.arc(point.x * dstCanvas.width, point.y * dstCanvas.height, outerRadius, 0, 2 * Math.PI);
                dstContext.fillStyle = 'white'; // 外圆填充白色
                dstContext.fill();
                dstContext.closePath();

                // 绘制内圆（橙色）
                dstContext.beginPath();
                dstContext.arc(point.x * dstCanvas.width, point.y * dstCanvas.height, innerRadius, 0, 2 * Math.PI);
                dstContext.fillStyle = color; // 内圆填充橙色
                dstContext.fill();
                dstContext.closePath();
            }

                function drawPoint_nXY_X(point, color, dstContext = copy_ctx, dstCanvas = copy_canvas, size = 20, alpha = 0.3) {
                    const x = point.x * dstCanvas.width;
                    const y = point.y * dstCanvas.height;

                    // 设置画笔颜色和粗细
                    dstContext.strokeStyle = color;
                    dstContext.lineWidth = size*0.25;

                    // 绘制第一条斜线（\）
                    dstContext.beginPath();
                    dstContext.moveTo(x - size, y - size);
                    dstContext.lineTo(x + size, y + size);
                    dstContext.stroke();
                    dstContext.closePath();

                    // 绘制第二条斜线（/）
                    dstContext.beginPath();
                    dstContext.moveTo(x + size, y - size);
                    dstContext.lineTo(x - size, y + size);
                    dstContext.stroke();
                    dstContext.closePath();
                }
    
                // 处理鼠标点击事件
                function handleMouseDown(event) {
                    if (bottomControls.style.display==='block'){
                        bottomControls.style.display='none';
                    }
                    const rect = court_canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    // console.log(x, y);
                    if (srcPoints.length < 4) {
                        let point = { x: x, y: y };
                        srcPoints.push(point);
                        dstPoints.push(point);
                        drawPoint(
                            point,
                            "yellow",
                            (context = court_ctx),
                            (radus = 20),
                            (alpha = 0.3)
                        );
                        if(srcPoints.length ==4){
                            EndlocatePoints.disabled=false;
                        }
                        return;
                    }

                    
                    for (let i = 0; i < 4; i++) {
                        if (
                            Math.sqrt(
                                Math.pow(x - dstPoints[i].x, 2) + Math.pow(y - dstPoints[i].y, 2)
                            ) <= 20
                        ) {
                            selectedPoint = i;
                            return;
                        } else {
                            // drawPoint({ x: x, y: y }, "blue", court_ctx, 5);
                            // let input_point = [[x], [y], [1]];
                            // let output_point;
                            // if (ipm) {
                            //     output_point = dot(ipm, input_point);
                            //     output_point[0] /= output_point[2];
                            //     output_point[1] /= output_point[2];
                            //     drawPoint_nXY(
                            //         {
                            //             x: (output_point[0] - court_x) / (court_canvas.width - 2 * court_x),
                            //             y:(output_point[1] - court_y) / (court_canvas.height - 2 * court_y),
                            //         },
                            //         "orange",
                            //         copy_ctx,
                            //         copy_canvas,
                            //         5
                            //     );
                            //     console.log(output_point);
                            // }
                        }
                    }
                    selectedPoint = -1;
                }
    
                // 处理鼠标移动事件
                function handleMouseMove(event) {
                    // if (bottomControls.style.display==='block'){
                    //     bottomControls.style.display='none';
                    // }
                    if (selectedPoint >= 0) {
                        const rect = court_canvas.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        dstPoints[selectedPoint] = { x, y };
                        drawScene();
                    }
                }
    
                // 处理鼠标释放事件
                function handleMouseUp(event) {

                    bottomControls.style.display = 'block';
                                // 如果之前已经设置了定时器，则清除之前的定时器
                    if (timer) {
                        clearTimeout(timer);
                    }
                    // 设置一个定时器，在 6 秒后隐藏 #bottomControls
                    timer = setTimeout(() => {
                        bottomControls.style.display = 'none';
                    }, 3000);

                    if (selectedPoint >= 0) {
                        drawScene();
                        selectedPoint = -1;
                    }
                }
    
                // // 应用透视变换
                function applyPerspectiveTransform() {
                    const rect = court_canvas.getBoundingClientRect();
                    const data = {
                        src_points: srcPoints,
                        dst_points: dstPoints,
                    };
                    fetch("/calculate_perspective_matrix", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(data),
                    })
                        .then((response) => response.json())
                        .then((data) => {
                            ipm = data.perspective_matrix;
                            // 假设 response 是从后端收到的 JSON 响应对象
                            var outputImageBase64 = data.output_image_base64;
    
                            var img = new Image();
                            img.src = "data:image/jpeg;base64," + outputImageBase64;
                            img.onload = function () {
                                // var court_canvas = document.getElementById("court_canvas");
                                // var court_ctx = canvas.getContext("2d");
                                court_ctx.drawImage(img, 0, 0, court_canvas.width, court_canvas.height);
                                drawPoints();
                            };
                            // 这里可以根据需要处理从服务器端接收到的透视变换矩阵
                        })
                        .catch((error) => {
                            console.error("Error:", error);
                        });
                    drawPoints();
                }
    
                // 设置事件监听器
                function setupEventListeners() {
                    court_canvas.addEventListener("mousedown", handleMouseDown);
                    court_canvas.addEventListener("mousemove", handleMouseMove);
                    court_canvas.addEventListener("mouseup", handleMouseUp);
                }

                // 当DOM加载完成后初始化Canvas并设置事件监听器
                document.addEventListener("DOMContentLoaded", function () {
                    initCanvas();
                    setupEventListeners();
                    let dropdownToggle = document.getElementById('dropdownMenuButton');
                    dropdownToggle.click();
                });
            </script>
</body>
</html>
